<?xml version="1.0" encoding="UTF-8"?>
<?script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"?>
<?script src="https://cdn.jsdelivr.net/npm/rhino3dm@8.6.0/rhino3dm.min.js"?>
<zk xmlns="http://www.zkoss.org/2005/zul">
    <style>
        text {
            pointer-events: none;
        }
        .node:hover {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 4px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
    </style>
    <window title="Neural Network Visualization">
        <vlayout>
            <hlayout>
                <label value="Input Layer Nodes:"/>
                <textbox id="inputNodes"/>
            </hlayout>
            <hlayout>
                <label value="Hidden Layer Nodes:"/>
                <textbox id="hiddenNodes"/>
            </hlayout>
            <hlayout>
                <label value="Output Layer Nodes:"/>
                <textbox id="outputNodes"/>
            </hlayout>
            <button label="Update Graph" onClick="javascript:updateGraph()"/>
        </vlayout>
        <div id="graph-container"></div>
        <script><![CDATA[
        var width = 960,
            height = 500,
            nodeSize = 30;

        var color = d3.scale.category20();

        var svg = d3.select("#graph-container").append("svg")
            .attr("width", width)
            .attr("height", height);

        function updateGraph() {
            var inputNodes = parseInt(jq("$inputNodes").val());
            var hiddenNodes = parseInt(jq("$hiddenNodes").val());
            var outputNodes = parseInt(jq("$outputNodes").val());

            var nodes = [];

            for (var i = 0; i < inputNodes; i++) {
                nodes.push({label: "i" + i, layer: 1});
            }
            for (var j = 0; j < hiddenNodes; j++) {
                nodes.push({label: "h" + j, layer: 2});
            }
            for (var k = 0; k < outputNodes; k++) {
                nodes.push({label: "o" + k, layer: 3});
            }

            var netsize = {};
            nodes.forEach(function (d) {
                if (d.layer in netsize) {
                    netsize[d.layer] += 1;
                } else {
                    netsize[d.layer] = 1;
                }
                d["lidx"] = netsize[d.layer];
            });

            var largestLayerSize = Math.max.apply(
                null,
                Object.keys(netsize).map(function (i) {
                    return netsize[i];
                })
            );

            var xdist = width / Object.keys(netsize).length,
                ydist = height / largestLayerSize;

            nodes.forEach(function (d) {
                d["x"] = (d.layer - 0.5) * xdist;
                d["y"] = (d.lidx - 0.5) * ydist;
            });

            svg.selectAll("*").remove();

            var node = svg.selectAll(".node")
                .data(nodes)
                .enter().append("g")
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

            var circle = node.append("circle")
                .attr("class", "node")
                .attr("r", nodeSize)
                .style("fill", function (d) {
                    return color(d.layer);
                });

            node.append("text")
                .attr("dx", "-.35em")
                .attr("dy", ".35em")
                .text(function (d) {
                    return d.label;
                });
        }
        // Initialize graph with default values
        updateGraph();
        ]]></script>

    </window>
</zk>
